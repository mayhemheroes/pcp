# common preamble for lots of parts of the PCP QA environment ...
# set $PATH, config-driven setup, etc
#
# Copyright (c) 1997-2002 Silicon Graphics, Inc.  All Rights Reserved.
#

#
# From pcpintro(1) man page ...
#
unset PCP_STDERR PCP_SECURE_SOCKETS
unset PMCD_CONNECT_TIMEOUT PMCD_RECONNECT_TIMEOUT
unset PMCD_REQUEST_TIMEOUT PMCD_WAIT_TIMEOUT
unset PMNS_DEFAULT PCP_COUNTER_WRAP
unset PMDA_PATH PMCD_PORT PMLOGGER_PORT
unset PMDA_LOCAL_PROC PMDA_LOCAL_SAMPLE PMIECONF_PATH
unset PMPROXY_PORT PMPROXY_HOST

# source the PCP configuration environment variables
if [ -r $PCP_DIR/etc/pcp.env ]
then
    . $PCP_DIR/etc/pcp.env
else
    echo "Error: unable to read $PCP_DIR/etc/pcp.env!" >&2
    exit 1
fi

# augment $PATH for QA specific dirs
#
for __dir in /sbin /usr/sbin
do
    [ -d "$__dir" ] && PATH="$PATH:$__dir"
done
export PATH

# QA default environment variables
PCP_PMCD_PROG=$PCP_BINADM_DIR/pmcd
PCP_PMCDLOG_PATH=$PCP_LOG_DIR/pmcd/pmcd.log
export PCP_PMCD_PROG PCP_PMCDLOG_PATH

# In openSUSE 12.1, /etc/rc.status intercepts our rc script and passes
# control to systemctl which uses systemd ... the result is that messages
# from our rc scripts are sent to syslog by default, and there is no
# apparent way to revert to the classical behaviour, so this "hack" allows
# PCP QA to set $PCPQA_NO_RC_STATUS and continue to see stdout and stderr
# from our rc scripts
# - Ken 1 Dec 2011
#
PCPQA_NO_RC_STATUS=
export PCPQA_NO_RC_STATUS

case $PCP_PLATFORM
in
    linux|freebsd|netbsd|openbsd|solaris|aix)
    	DSO_SUFFIX=so
	;;
    darwin)
	DSO_SUFFIX=dylib
	;;
    mingw)
	DSO_SUFFIX=dll
	;;
esac

# does sudo support -E?
#
# sudo usage in two forms ...
#	sudo ... [-AbEHknPS] ...
# or
#	-E, --preserve-env
#
sudo=`which sudo`
case $PCP_PLATFORM
in
    darwin)
	# I cannot make this work on Mac OS X ... kenj
	;;
    *)
	if $sudo -h 2>&1 | egrep '(\[-[a-zA-DF-Z]*E[a-zA-Z]*\])|(.-E[, 	])' >/dev/null 2>&1
	then
	    # sudo has -E to preserve the environment
	    #
	    sudo="$sudo -E"
	fi
	;;
esac

# $sudo_local_ctx maybe $sudo if PM_CONTEXT_LOCAL needs to run as root,
# e.g. for /dev/kmem readers
#
case $PCP_PLATFORM
in
    netbsd|openbsd|solaris)
    	sudo_local_ctx="$sudo"
	;;
    *)
	sudo_local_ctx=''
	;;
esac

# running with PCP_DIR set, probably don't want to do most things as
# root ... leave $sudo alone just in case
# However, if $PCP_DIR exists and is owned by someone other than ourselves,
# real sudo is guessed necessary.
if [ -n "$PCP_DIR" ]
then
    __pcp_dir_owner=`ls -ld $PCP_DIR | awk '{print $3}'`
    __whoami=`whoami`
    if [ "$__pcp_dir_owner" = "$__whoami" ]; then
        sudo=''
    fi
fi
here=`pwd`

if [ -z "$tmp" ]
then
    # $tmp not already set, do it here ...
    #
    if [ -z "$seq" ]
    then
	tmp=/var/tmp/$$
    else
	tmp=/var/tmp/$seq-$$
    fi
fi

# We depend on [A-Za-z] and similar patterns all over ... for some
# platforms this demands LC_COLLATE to be POSIX to avoid case
# insensitive matching
#
export LC_COLLATE=POSIX

# If we're using timeout(1) -s ABRT from check, it helps to trap the
# SIGABRT (signal 6), explain why you're quitting, then kill yourself
# with SIGTERM
#
trap 'echo "!!!"; echo "!!! Killed from check by timeout ..."; echo "!!!"; pmsignal -s TERM '$$ 6
